<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æŸ³æ™ºæ•åé»‘å¹³å° | Karina Anti-Hate</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;500;700&display=swap');
        body { font-family: 'Noto Sans SC', sans-serif; margin: 0; overflow: hidden; background-color: #050510; color: white; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; }
        #ui-layer { position: relative; z-index: 10; min-height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; backdrop-filter: blur(2px); }
        .glass-panel { background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border: 1px solid rgba(255, 255, 255, 0.1); box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3); }
        .fade-out { opacity: 0; transform: scale(0.95); transition: all 0.5s ease-in-out; pointer-events: none; }
        .fade-in { opacity: 1; transform: scale(1); transition: all 0.5s ease-in-out; }
        .hidden-section { display: none; opacity: 0; }
        .result-text-gradient { background: linear-gradient(to right, #e0e7ff, #c084fc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .cursor-blink { display: inline-block; width: 4px; height: 1em; background-color: #c084fc; margin-left: 4px; animation: blink 1s step-end infinite; vertical-align: middle; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="section-input" class="w-full max-w-2xl px-6 flex flex-col items-center transition-all duration-500">
            <h1 class="text-4xl md:text-5xl font-bold mb-2 tracking-widest text-transparent bg-clip-text bg-gradient-to-r from-purple-300 to-indigo-300">KARINA</h1>
            <p class="text-gray-400 mb-8 text-sm tracking-widest uppercase">Anti-Hate Platform</p>
            <div class="glass-panel rounded-2xl p-1 w-full relative group">
                <textarea id="user-input" rows="3" class="w-full bg-transparent text-white text-lg p-6 resize-none rounded-xl placeholder-gray-500 border border-transparent focus:bg-white/5 transition-all" placeholder="è¾“å…¥è¦åˆ¤å®šçš„è¯­å¥..."></textarea>
                <div class="absolute bottom-4 right-4">
                    <button id="btn-start" onclick="startStream()" class="bg-indigo-600 hover:bg-indigo-500 text-white font-medium py-2 px-6 rounded-lg shadow-lg shadow-indigo-500/30 transition-all transform hover:scale-105 active:scale-95 flex items-center gap-2">
                        <span>å¼€å§‹åˆ¤å®š</span>
                    </button>
                </div>
            </div>
        </div>

        <div id="section-result" class="hidden-section w-full max-w-5xl px-6 text-center flex flex-col items-center">
            <div id="status-text" class="mb-6 text-indigo-300 text-sm tracking-widest uppercase border-b border-indigo-500/30 pb-2 animate-pulse">Initializing...</div>
            <div class="min-h-[150px] flex justify-center items-center">
                <div id="result-content" class="text-4xl md:text-6xl font-bold leading-tight result-text-gradient drop-shadow-2xl"></div>
                <span id="cursor" class="cursor-blink hidden"></span>
            </div>
            <button id="btn-restart" onclick="resetApp()" class="mt-12 opacity-0 pointer-events-none border border-gray-600 text-gray-400 hover:text-white hover:border-white px-8 py-2 rounded-full transition-all text-sm uppercase tracking-wider">é‡æ–°æµ‹è¯•</button>
        </div>
    </div>

    <script>
        // --- Three.js åˆå§‹åŒ–ä»£ç  (ä¿æŒä¸å˜) ---
        const initThreeJS = () => {
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x050510, 0.002);
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.z = 30;
            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight); container.appendChild(renderer.domElement);
            const geometry = new THREE.BufferGeometry(); const count = 2000;
            const pos = new Float32Array(count * 3); const col = new Float32Array(count * 3);
            for(let i=0; i<count*3; i++) { pos[i]=(Math.random()-0.5)*100; col[i]=Math.random(); }
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
            const material = new THREE.PointsMaterial({ size: 0.3, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
            const particles = new THREE.Points(geometry, material); scene.add(particles);
            let mx=0, my=0; document.addEventListener('mousemove', e => { mx=(e.clientX-innerWidth/2)*0.05; my=(e.clientY-innerHeight/2)*0.05; });
            function animate() { requestAnimationFrame(animate); particles.rotation.x += 0.0005; particles.rotation.y += 0.0005; camera.position.x += (mx - camera.position.x)*0.05; camera.position.y += (-my - camera.position.y)*0.05; camera.lookAt(scene.position); renderer.render(scene, camera); }
            animate();
            window.addEventListener('resize', () => { camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
        };
        initThreeJS();

        // --- æ ¸å¿ƒé€»è¾‘: Coze API é›†æˆ ---
        
        const COZE_CONFIG = {
            // ğŸš¨ æ›´æ–°åçš„ API Token
            token: 'cztei_qY9D9y47MIlOyDuWReBJr2e3fiaJV5hWqns081mLg4diccESrwmK0jz5dHRNIbkB7',
            bot_id: '7578219795532251145', 
            baseURL: 'https://api.coze.cn'
        };

        const els = {
            inputSec: document.getElementById('section-input'),
            resultSec: document.getElementById('section-result'),
            userInput: document.getElementById('user-input'),
            resultContent: document.getElementById('result-content'),
            statusText: document.getElementById('status-text'),
            cursor: document.getElementById('cursor'),
            restartBtn: document.getElementById('btn-restart')
        };

        let hasReceivedContent = false;

        async function startStream() {
            const text = els.userInput.value.trim();
            if (!text) return alert("è¯·è¾“å…¥å†…å®¹");

            // UI çŠ¶æ€åˆ‡æ¢
            els.inputSec.classList.add('fade-out');
            setTimeout(() => {
                els.inputSec.style.display = 'none';
                els.resultSec.style.display = 'flex';
                els.resultContent.innerHTML = ''; 
                hasReceivedContent = false;
                els.cursor.classList.remove('hidden');
                requestAnimationFrame(() => {
                    els.resultSec.classList.remove('hidden-section');
                    els.resultSec.classList.add('fade-in');
                });
            }, 500);

            try {
                els.statusText.innerText = "Connecting to AE...";
                
                // æ„é€ è¯·æ±‚ä½“ï¼Œä¸¥æ ¼å¯¹é½ SDK ç¤ºä¾‹ç»“æ„
                const requestBody = {
                    bot_id: COZE_CONFIG.bot_id,
                    user_id: 'web_user_' + Date.now(),
                    stream: true,
                    // æ ¸å¿ƒæ¶ˆæ¯å†…å®¹
                    additional_messages: [
                        {
                            "content": text,
                            "content_type": "text",
                            "role": "user",
                            "type": "question",
                            "meta_data": {} // ä¿æŒç©ºå¯¹è±¡
                        }
                    ],
                    custom_variables: {}, // ä¿æŒç©ºå¯¹è±¡
                    meta_data: {},        // ä¿æŒç©ºå¯¹è±¡
                    extra_params: {},     // ä¿æŒç©ºå¯¹è±¡
                };

                const response = await fetch(COZE_CONFIG.baseURL + '/v3/chat', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${COZE_CONFIG.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText}`);
                }

                els.statusText.innerText = "Analyzing Stream...";
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let buffer = "";
                let currentEvent = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;
                    
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); 

                    for (const line of lines) {
                        const trimmedLine = line.trim();
                        if (!trimmedLine) continue;

                        if (trimmedLine.startsWith('event:')) {
                            currentEvent = trimmedLine.substring(6).trim();
                        }
                        else if (trimmedLine.startsWith('data:')) {
                            const dataStr = trimmedLine.substring(5).trim();
                            if (dataStr === '[DONE]') continue;

                            try {
                                const data = JSON.parse(dataStr);

                                // ç­–ç•¥ A: å®æ—¶å¢é‡ (Delta)
                                if (currentEvent === 'conversation.message.delta' && data.content) {
                                    hasReceivedContent = true;
                                    els.resultContent.innerText += data.content;
                                }
                                // ç­–ç•¥ B: å®Œæ•´åŒ… (Completed)
                                else if (currentEvent === 'conversation.message.completed') {
                                    if (data.type === 'answer' && data.content) {
                                        // å…œåº•å¤„ç†ï¼šå¦‚æœå¢é‡æ²¡æ”¶åˆ°ï¼Œæˆ–è€…å†…å®¹ä¸å…¨ï¼Œä½¿ç”¨ completed å®Œæ•´å†…å®¹
                                        if (!hasReceivedContent || els.resultContent.innerText.length < data.content.length) {
                                             if (!hasReceivedContent) {
                                                 simulateTypewriter(data.content);
                                             } else {
                                                 els.resultContent.innerText = data.content;
                                             }
                                             hasReceivedContent = true;
                                        }
                                    }
                                }
                            } catch (e) {
                                // å¿½ç•¥è§£æé”™è¯¯
                            }
                        }
                    }
                }
                
                finishStream();

            } catch (error) {
                console.error("Stream Error:", error);
                els.statusText.innerText = "Connection Failed";
                els.resultContent.innerHTML = `<span style="font-size:20px; color:#f87171;">âš ï¸ è¯·æ±‚å¤±è´¥<br><span style="font-size:14px; opacity:0.7">${error.message}</span><br><span style="font-size:12px; opacity:0.5; margin-top:10px; display:block;">è¯·ç¡®ä¿å·²å®‰è£… 'Allow CORS' æ’ä»¶æˆ–é…ç½®äº†ä»£ç†</span></span>`;
                els.cursor.classList.add('hidden');
                els.restartBtn.classList.remove('opacity-0', 'pointer-events-none');
            }
        }

        // æ‰‹åŠ¨æ¨¡æ‹Ÿæ‰“å­—æœºæ•ˆæœ
        function simulateTypewriter(fullText) {
            els.resultContent.innerText = '';
            let i = 0;
            const speed = 30;
            function type() {
                if (i < fullText.length) {
                    els.resultContent.innerText += fullText.charAt(i);
                    i++;
                    setTimeout(type, speed);
                } else {
                    finishStream();
                }
            }
            type();
        }

        function finishStream() {
            if (!hasReceivedContent && els.resultContent.innerText === '') {
                 els.resultContent.innerText = "ï¼ˆAI æœªè¿”å›æœ‰æ•ˆç»“æœï¼Œè¯·é‡è¯•ï¼‰";
            }
            els.statusText.innerText = "Analysis Complete";
            els.statusText.classList.remove('animate-pulse');
            els.cursor.classList.add('hidden');
            els.restartBtn.classList.remove('opacity-0', 'pointer-events-none');
        }

        function resetApp() {
            els.resultSec.classList.remove('fade-in');
            els.resultSec.classList.add('fade-out');
            setTimeout(() => {
                els.resultSec.style.display = 'none';
                els.resultSec.classList.remove('fade-out');
                els.resultSec.classList.add('hidden-section');
                
                els.restartBtn.classList.add('opacity-0', 'pointer-events-none');
                els.userInput.value = '';
                els.inputSec.style.display = 'flex';
                els.inputSec.classList.remove('fade-out');
            }, 500);
        }
    </script>
</body>
</html>